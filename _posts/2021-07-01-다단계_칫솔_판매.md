---
title: "Coding Test - 다단계 칫솔 판매"
date: 2021-07-01
categories: CodingTest
---

Click [programmers coding test link](https://programmers.co.kr/learn/challenges)



### 문제파악하기
___
#### 목표
다단계 조직에서 발생하는 이익금을 판매원들에게 분배하기  
각 판매원 추천인에게 이익금의 10% 분배한다, 개당 이익 100원 (단, 1원 미만 금액은 절사)
#### 입출력 변수
* enroll: 조직에서 가장 꼭대기에 있는 한명(center)를 제외 한 조직 구성원 명단 (type: list) 
* referral: 배열 enroll의 i 번째 사람의 추천인, center에 의해 추천되었다면 "-"기입됨 (type: list)
* seller: i번째 판매 집계 데이터의 판매자 이름, 중복가능 (type: list)
* amount: i번째 판매 집계 데이터의 판매량 (type: list)
* result: 최종적으로 판매원들에게 배분된 이익금의 총합 리스트, enroll의 명단 순서에 따라 나열

### 1차시도
___
#### code
```python 
def solution(enroll, referral, seller, amount):
    result = [0] * len(enroll)

    j = 0
    for s in seller:
        # seller[j]의 이익 추가시키기
        i = enroll.index(s)
        p = amount[j] * 100
        result[i] += p - p // 10 

        # seller[j]의 추천인들의 이익 추가시키기
        while referral[i] != "-" and p // 10 != 0:
            i = enroll.index(referral[i])
            p = p // 10
            result[i] += p - p // 10 
        
        j += 1
        
    return result
```
#### 결과
![1차시도_결과](https://user-images.githubusercontent.com/86001773/124390646-892fb400-dd27-11eb-8a72-0507b7dd09ac.PNG)  
  
#### 분석
seller의 최대 길이가 100,000인데 이 중에 중복이 발생할 수 있다.  
이 중복을 없애지 않은 상태로 seller 배열을 사용하면   
이미 찾은 추천인들을 또 찾는 시간낭비를 하게된다.  
따라서 seller의 중복을 없애고 각 seller마다 판매수량을 집계하여    
중복없이 seller별로 이익을 분배하도록 해야겠다.  

### 2차시도
___
#### code
```python
def solution(enroll, referral, seller, amount):
    # seller 배열에서 중복 제거하기 -> 사람이름: key, 판매수량: value로 하는 딕셔너리 생성
    seller_dict = {}
    i = 0
    for s in seller:
        if s in seller_dict.keys():
            seller_dict[s] += amount[i]
        else:
            seller_dict[s] = amount[i]
        i += 1    
    
    result = [0] * len(enroll)
    j = 0
    for s in seller_dict.keys():
        # seller_dict.keys()[j]의 이익 추가시키기
        i = enroll.index(s)
        p = list(seller_dict.values())[j] * 100
        result[i] += p - p // 10
        p = p // 10

        # seller_dict.keys()[j]의 추천인들의 이익 추가시키기
        while referral[i] != "-" and p >= 1:
            i = enroll.index(referral[i])
            result[i] += p - p // 10
            p = p // 10
        
        j += 1
        
    return result
```
#### 결과
![2차시도_결과](https://user-images.githubusercontent.com/86001773/128590733-aaefacc7-7b40-46e7-b930-42d6622b2fec.PNG)
#### 분석
단순히 중복을 없애기 위해 seller 이름별로 판매량 합해서 집계하면   
1원 미만 절사 규칙을 위배하는 경우가 발생한다.  

따라서 seller 이름별로 판매량을 집계하되   
한번의 판매량을 각 원소로 하는 리스트 형태로 seller와 amount를 변형하는것이 필요할 것 같다. 

즉, key: seller 이름, value: 한번의 판매량을 원소로 하는 리스트인 딕셔너리를 생성하고,   
seller 한명의 추천인들을 찾는 반복문을 처음 거칠때 추천인들을 리스트에 저장해서   
seller 한 사람 당 반복문을 한번만 사용하도록 하겠다.   

### 3차시도
___
#### code
```python
# seller 배열에서 중복 제거하기 
# -> key: seller 이름, value: 한번의 판매량을 원소로 하는 리스트인 딕셔너리 생성
seller_dict = {}
i = 0
for s in seller:
    if s in seller_dict.keys():
        seller_dict[s].append(amount[i])
    else:
        seller_dict[s] = []
        seller_dict[s].append(amount[i])
    i += 1
```


```python
# seller의 추천인들 찾기
recommender = []
i = 0
for s in seller_dict.keys():
    index = enroll.index(s)
    recommender.append([index])
    while referral[index] != "-":
        index = enroll.index(referral[index])
        recommender[i].append(index)
    i += 1
```


```python
# 이익 분배하기
result = [0] * len(enroll)
i = 0
for s in seller_dict.keys():
    for a in seller_dict[s]:
        p = a * 100
        for j in recommender[i]:
            if p < 1:
                break
            elif j == recommender[-1]:
                result[j] += p 
            else:
                result[j] += p - p // 10
                p = p // 10
    i += 1        
```


```python
def solution(enroll, referral, seller, amount):    
    # seller 배열에서 중복 제거하기 
    # -> key: seller 이름, value: 한번의 판매량을 원소로 하는 리스트인 딕셔너리 생성
    seller_dict = {}
    i = 0
    for s in seller:
        if s in seller_dict.keys():
            seller_dict[s].append(amount[i])
        else:
            seller_dict[s] = []
            seller_dict[s].append(amount[i])
        i += 1

    # seller의 추천인들 찾기
    recommender = []
    i = 0
    for s in seller_dict.keys():
        index = enroll.index(s)
        recommender.append([index])
        while referral[index] != "-":
            index = enroll.index(referral[index])
            recommender[i].append(index)
        i += 1

    # 이익 분배하기
    result = [0] * len(enroll)
    i = 0
    for s in seller_dict.keys():
        for a in seller_dict[s]:
            p = a * 100
            for j in recommender[i]:
                if p < 1:
                    break
                elif j == recommender[-1]:
                    result[j] += p 
                else:
                    result[j] += p - p // 10
                    p = p // 10
        i += 1

    return result
```
#### 결과
![3차시도_결과](https://user-images.githubusercontent.com/86001773/128591167-12849f2b-48b8-41f8-8dea-b52f4743956f.PNG)








  
